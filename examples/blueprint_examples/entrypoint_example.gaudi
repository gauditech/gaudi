auth Auth {
    plugin gaudi/auth
    attach to model User
}

model User as this {
    field full_name type string
    field is_superadmin type boolean
    query org_membership (org_) { from org_memberships, filter { org_ is org }, first, select { role }}
    computed org_role (org) { org_membership(org).role }
    auth {
        role org_admin (org) {
            org_role (org) == 'admin'
        }
        role org_editor (org) {
            org_role (org) == 'editor'
         }
         role org_member (org) { org_mem }
         role org_issue_assignee ...
         role issue_asignee (issue) {
            this is in issue.assignees
         }
         role paid_user { this.is_paid is true }
         role free_user { this.is_paid is false }
         role user { true } # authenticated, anonymous
         role superadmin { is_superadmin }
    }
}

user.org_admin(org)
org.user_is_admin(user)

# in entrypoints, *exactly one* role must match (first one?)
# we have 2 uses for a role:
# 1. with ownership on a resource (update, delete, get)
# 2. with ownership on a parent resource (all)
# 3. without ownership on a resource, with external rules (eg. free vs paid)

## Questions:
# What if 'internal' role gives access to parent resource
# What if combination of roles is needed for an access (AND)
# What if one of roles is needed (OR)
# Think documentation

entrypoint Org as o {
    name Organizations
    identify with slug
    action create {
        role free_user, fieldset CreateFreeOrgFieldset
        role paid_user, fieldset CreateOrgFieldset

        # what if there's extra memberships data sent from client, but server adds
        # @auth as a user, would we assume `memberships.0`?
        # we're inserting two records, custom action or? this is common req I think
        transform { push memberships, { add user @auth }}
    }
    action list {
        role superadmin
        role org_member(o), filter { is_public or } <--- ??
        role *, filter { is_public } # anyone, including anonymous Users
        # should we have implicit anonymous role? authenticated too?
    }
    action get {
        role org_member(o)
        role *, filter { is_public }
    }
    action update {
        role free_user, fieldset UpdateFreeOrgFieldset
        role paid_user, fieldset UpdateOrgFieldset
    }
    action delete { role org_admin(o) or org_editor(o) }
    entrypoint repos as r {
        ...
        action list {
            role org_member(o)
        }
    }
}

entrypoint Org as o {
    action list {
        features {
            search_fields org.members.full_name, min 4, pg_trym, like / startwith, required
            limit, default 10, max 1000
        }
        role superadmin
        role * {
            assert filter_field members.full_name, min 4, method like
            assert org.members.full_name in @request.query.filters
            assert @request.query.filters[org.members.full_name], min 4
            assert @@fieldset
        }
    }
    action get {}
    action search { <-- /list sa obaveznim paramom min 4 znaka npr }
}

fieldset CreateOrgFieldset {
    take Org.{
        name, desc, slug
        memberships.{ role }
        repos.{
            name, desc, slug
            labels                          #.{ * }
            issues.{ name, labels }
            pull_requests.{ name, labels }
        }
    }

    validate memberships {
        required, length 1
    }

    validate repos { missing }

    # enter repos {}
    take repos
}

fieldset UpdateOrgFieldset {
    validate memberships { missing }
    enter memberships {
        pick role
    }
    drop slug
    drop repos.slug
    role!!
    # imamo slucaj issue.labels se submitta cijeli
    # memberships se nikad ne submitta cijeli
    # kako znamo da ne zelimo endpoint set za issue.labels (jer je m2m),
    # a zelimo za membership? (isto m2m)
}


# A sto kad bi imali:
- entrypoint za select
    - treba nam nested filter onda.
- actions za sve ostalo
- sto je sa custom READ akcijama? ima li to smisla?
    - mozda za REST
- actions bi trebao sam moci izbuildati REST?
- ili: kako bi se buildao REST iz actionsa?


Open questions:
- kreiranje vise recorda odjednom
- sintaksa entrypointa
- sintaksa za pickanje nestanog fieldseta / kombinacija s fieldsetima, embedanje i sl.

Decisions:
- role se izvrsavaju kao case, redom do prvog matcha
- nemamo custom actiona, tj. koristimo inicijalnu action ideju (low req.)
- nestani fieldseti po zelji ako dev bas zeli, nije implicitno
- 

1. finalna sintaksa za:
- modele +
    - auth i role!
    - vise authova?
    - token auth?
- hooks (model, fieldset, entrypoint)
- validaciju s custom validatorima +
- entrypointove / endpointove / graphql, stogod, razmisliti o live queryjima
    - hookanje autha
    - custom actione??
    - slackops?
    - jslib naminga?
- transformacije vrijednosti