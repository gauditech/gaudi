# Topics:
- field validation
- non-field validation (eg. "Group is full")
- composite field validation ("start_date must be before end_date")
- pattern-match error states
- custom (constraint) errors, map to fields (ecto!)


validation {
    field full_name {
        string "invalid type"
        min 1 "too short"
        max 10 "too long"
    }
}

validation {}

endpoint /search_by_oib {
    param oib_start
    param limit

    validate {
        field limit {
            max 1000 ["limit_too_large", param.limit, 1000]
        }
    }
    on_validation_error {
        transform GlobalI80nErrorMessageTransformer auth.user.language
    }
}

validator oib {
    
}

unique lower(email) <-- constraint

error response:

{  // data: 
   // status: "ok"
    errors: [
        { code: "not-found", params: [], message: "", field: "field1" }
    ]
}

i80n {
    "not a valid range" (min, max, entry) -> "Please enter a number between $min and $max"
}

function backend_error(code, arguments) {
    return t.entries("__backend__." + code, arguments)
}

{
    ........


    "___backend___.not_a_valid_range": "You have entered $entry, please enter a number between $min and $max"
}

{
    errors: {
        field1: [{code, message, params: {max, min, value}}, ...],
        field2: [{...}],
        custom: [{...}],
        non_field_errors: []
    }
}

validator between {
    param min
    param max default 1000
    param min_field default @param.min
    param msg_below "Value $value ..."

    code "value_too_low"
    message @param.msg_below
    assert value <= max

    code "value_not_in_range"
    message "Value $value is not between @param.min and $max!"
    assert value >= min
}


validator between {
    param value1 nullable
    param value2 nullable
    param min
    param max default 1000

    expect value required
    expect value string
}


validator after {
    arg after_date
    assert after_date < value
    code "value_before_date"
}


changeset registration {
    field email, type email <-- User
    field org_name, type text <-- Organization
    field full_name, type text <-- User

    pick User.{email, full_name}

    validate email {
        is_email_regex
    }
    validate org_name {
        min 6, max 20
    }
}

insert ch into User (compile-time errors)


user_ch = transform ch {
    pick email, full_name
}
insert user_ch into User
org_ch = transform ch {
    pick org_name
}
insert org_ch into Organization


autoadmin { except User, GroupMembership }

changeset changeset1 {
    field ...
    field ...
}

admin UserView {
    model User
    select ...
    create_changeset changeset1
    # create_action {...}
}

model User {
    field full_name {
        validate {
            ...
        }
    }

    field full_name

    validate full_name {
        ...
    }
}


endpoint /search_by_oib {
    query_param oib_start
    query_param limit

    # 1. url parami /users/1/ sto je s /users//
    # 2. query parami /users?id=1
    # 3. body (post) parami - json body

    @request.path_params
    @request.query_params
    @request.body
    @request.params

    imas POST /users/1/posts
    imas @request.path_params.user_id == 1
    imas @request.body koji ima { message, is_private }
    imas changeset za body
    validiras changeset
    validiras auth za user_id
    zelis insertat changeset, errora jer nema user_id
    rjesenje transform pa ga dodas
    changeset = {message, is_private}
    baza requirera {message, user_id, is_private}
    ne mozes insertat changeset jer nema user_id

    ch1 = validate @request.body with RegistrationChangeset
    if/else
    if ch1.ok ...
        ch1.data
    else
      throwar errore ili radi nesto drugo

    ch2 = transform ch1 {
        add user_id @user_id
    }

    ch2 mozes insertat



    insert User(@request.body)

    validate @request.params {
        validate non_field_errors {

        }
        # limit is_required
        min value limit, min 0
        between value limit, min 50, max 1000
        is_one_provided first limit, second big_limit, field_name "non_field_errors"
        limit between min 50, max 1000
        email, phone_num is_one_provided

        field limit {
            type positive_number
            between 0 1000 "not a valid range" "The moutain is too large!"
            between min 50, max 1000, code "not_a_valid_range", message "Not in range!"
            between {
                min 50
                max 1000
                code "not_a_valid_range"
                message "The mountain is larger than @param.min_field"
                extra_params another_field request.form.another_field
                # implicitni params su:
                # min 0, max 1000, value @param.limit
            }
        }
        field to {
            type date
            after @param.from_date # "$value must be after $after.field_name" => "2022-10-10 must be after from date"
        }
    }
    on_validation_error {
        transform GlobalI80nErrorMessageTransformer auth.user.language
    }
}


action {
    
}