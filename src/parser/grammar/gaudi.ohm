Gaudi {
  Definition
    = NewlineBody<(Model | Entrypoint | Hook), ";">

  // Override Ohm's built-in definition of space.
  space += comment



  // ********************
  // Model grammar
  // ********************

  Model = "model" IdentifierWithAs "{" NewlineBody<ModelBody, ";"> "}"

  ModelBody
    = Field
    | Reference
    | Relation
    | Query
    | Computed

  Field
    = "field" identifier "{" NonemptyNewlineBody<FieldBody, ","> "}"

  FieldBody
    = "type" identifier -- type
    | "default" literal -- default // we allow only literals for now
    | ("nullable" | "unique") -- tag
    | "validate" "{" NonemptyNewlineBody<Validator, ","> "}" -- validate

  Validator
    = identifier literal*

  Reference
    = "reference" identifier "{" NonemptyNewlineBody<ReferenceBody, ","> "}"

  ReferenceBody
    = "to" identifier -- to
    | ("nullable" | "unique") -- tag

  Relation
    = "relation" identifier "{" NonemptyNewlineBody<RelationBody, ","> "}"

  RelationBody
    = "from" identifier -- from
    | "through" identifier -- through

  Query
    = "query" identifier "{" NonemptyNewlineBody<QueryBody, ","> "}"

  QueryBody
    = "from" IdentifierPathWithAs -- from
    | "filter" OptionalBraces<QueryExp> -- filter
    | "order" "by" NonemptyListOf<QueryOrder, ","> -- order_by
    | "limit" integer -- limit

  QueryOrder = IdentifierPath ("asc" | "desc")?

  Computed
    = "computed" identifier "{" QueryExp "}"

  QueryExp = OrExp

  OrExp
    = OrExp or AndExp -- or
    | AndExp

  AndExp
    = AndExp and IsExp -- and
    | IsExp

  IsExp
    = IsExp is not InExp -- is_not
    | IsExp is InExp -- is
    | InExp

  InExp
    = InExp not in CompExp -- not_in
    | InExp in CompExp -- in
    | CompExp

  CompExp
    = CompExp "<" PrimaryExp -- lt
    | CompExp "<=" PrimaryExp -- lteq
    | CompExp ">" PrimaryExp -- gt
    | CompExp ">=" PrimaryExp -- gteq
    | PrimaryExp

  PrimaryExp
    = "(" QueryExp ")" -- paren
    | not PrimaryExp -- not
    | literal -- literal
    | IdentifierPath -- identifier



  // ********************
  // Entrypoint grammar
  // ********************

  Entrypoint = "entrypoint" identifier "{" NewlineBody<EntrypointBody, ";"> "}"

  EntrypointBody
    = "target" ("model" | "relation") IdentifierWithAs -- target
    | "identify" "with" identifier -- identify
    | "response" SelectBody -- response
    | Endpoint -- endpoint
    | Entrypoint -- entrypoint

  SelectBody = "{" NewlineBody<Select, ","> "}"
  Select
    = identifier SelectBody -- nested
    | identifier -- single

  Endpoint = EndpointType "endpoint" "{" NewlineBody<EndpointBody, ";"> "}"

  EndpointType
    = "list"
    | "get"
    | "create"
    | "update"
    | "delete"

  EndpointBody
    = "action" "{" NewlineBody<ActionBody, ";"> "}" -- action


  ActionKind = "create" | "update" | "delete"
  ActionBody
    = ActionKind "{" NewlineBody<ActionAtomBody, ";"> "}"                                     -- default
    | ActionKind IdentifierPath "{" NewlineBody<ActionAtomBody, ";"> "}"                      -- named
    | ActionKind IdentifierPath "as" identifier "{" NewlineBody<ActionAtomBody, ";"> "}"      -- aliased


  ActionAtomBody
    = "set" identifier literal                            -- set_value
    | "set" identifier IdentifierPath                     -- set_reference
    | "reference" identifier "through" identifier         -- reference
    | "input" "{" NewlineBody<ActionInputAtom, ","> "}"   -- input
    | "deny" DenyList                                     -- deny
    | ActionBody                                          -- nested_action

  ActionInputAtom
    = identifier "{" NewlineBody<ActionInputOpt, ","> "}" -- field_with_opts
    | identifier                                          -- field

  ActionInputOpt
    = "optional"                  -- optional
    | "default" literal           -- default_value
    | "default" IdentifierPath    -- default_reference

  DenyList
    = "*"                                         -- all
    | "{" NewlineBody<identifier, ","> "}"        -- some

  // ********************
  // Hook grammar
  // ********************

  Hook
    = "hook" identifier "{" NonemptyNewlineBody<HookBody, ";"> "}"

  HookBody
    = "arg" identifier identifier   -- argument
    | "returns" identifier          -- return_type
    | "inline" multiLineString      -- inline_body

  IdentifierPath = identifier ("." identifier)*

  IdentifierWithAs
    = identifier "as" identifier -- identifier_as
    | identifier -- identifier

  IdentifierPathWithAs
    = IdentifierPath "as" IdentifierPath -- identifier_as
    | IdentifierPath -- identifier

  literal (a literal) = null | boolean | integer | float | string

  boolean = true | false
  integer = digit+
  float = digit* "." digit*
  string = "\"" (~"\"" any)* "\""

  keywords = null | true | false | is | not | in
  null = "null" ~identifierPart
  true = "true" ~identifierPart
  false = "false" ~identifierPart
  or = "or" ~identifierPart
  and = "and" ~identifierPart
  is = "is" ~identifierPart
  not = "not" ~identifierPart
  in = "in" ~identifierPart

  identifier (an identifier) = identifierStart identifierPart*
  identifierStart = letter | "_" | "@"
  identifierPart = identifierStart | alnum

  OptionalBraces<Exp>
    = Exp -- no_braces
    | "{" Exp "}" -- braces

  NewlineBody<Exp, delimiter>
    = NonemptyNewlineBody<Exp, delimiter>
    | -- empty

  NonemptyNewlineBody<Exp, delimiter>
    = Exp (#delimiterOrNL<delimiter> Exp)* #delimiterOrNL<delimiter>?

  lineTerminator (a new line) = "\n" | "\r" | "\u2028" | "\u2029"

  delimiterOrNL<delimiter>
     = (~lineTerminator space)* (lineTerminator | delimiter)

  comment = multiLineComment | singleLineComment

  multiLineComment = "/*" (~"*/" any)* "*/"
  singleLineComment = "//" (~lineTerminator any)*

  multiLineString = "`" (~"`" any)* "`"
}
