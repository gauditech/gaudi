auth Auth {
    plugin gaudi/auth
    attach to model User
}

model User as this {
    field full_name type string
    field is_superadmin type boolean
    query org_membership (org_) { from org_memberships, filter { org_ is org }, first, select { role }}
    computed org_role (org) { org_membership(org).role }
    auth {
        role org_admin (org) {
            org_role (org) == 'admin'
        }
        role org_editor (org) {
            org_role (org) == 'editor'
         }
         role org_member (org) { org_mem }
         role org_issue_assignee ...
         role issue_asignee (issue) {
            this is in issue.assignees
         }
         role paid_user { this.is_paid is true }
         role free_user { this.is_paid is false }
         role user { true } # authenticated, anonymous
         role superadmin { is_superadmin }
    }
}

user.org_admin(org)
org.user_is_admin(user)

# in entrypoints, *exactly one* role must match (first one?)
# we have 2 uses for a role:
# 1. with ownership on a resource (update, delete, get)
# 2. with ownership on a parent resource (all)
# 3. without ownership on a resource, with external rules (eg. free vs paid)

## Questions:
# What if 'internal' role gives access to parent resource
# What if combination of roles is needed for an access (AND)
# What if one of roles is needed (OR)
# Think documentation

entrypoint Auth {
    action login {}
    action register {}
}

model Customer {
    name, 
    notes,
    relation contacts { type CustomerContact }
}

model CustomerContact {
    reference customer
    type, email? { address }, phone? { phnum }
}

fieldest { name, notes, contacts: { list, type, email, phone, validate xor {}}}

{
    name,
    notes,

    contacts: [
        { type: 'email', email: { address:'nest@nest' }},
        { type: "phone", phone: {phnum: "123456789" } }
    ]
}



{ id: 1, full_name: "marko" }
User<{ id: 1, full_name: "marko" }>

signup: kreiraj org, usera, membership <-- custom action

Db query:
1. beskonacno nema smisla
2. dolazak do nekog kraja / roota: `recursive`
3. graphql generirani kveriji

Rest vs Graphql

Entrypoint ::: User { name, friends { name, friends {name, friends { name }}}}


schema :org {
    field :name
    field :slug
    field :repos, list(:fullrepo)
}

schema :fullrepo {
    field :org, :org
    field :name
    field :slug
    field :num_of_prs
}

schema :repo {
    field :org_id
    field :name
    field :slug
    field :num_of_prs
}



{
    Org(id: 10, limit: 5): { <--- id moze biti optional
        <--- vraca listu
        name, slug,
        repos(limit: 5) {
            name, slug, num_of_issues, num_of_prs
        }
    }

    SingleOrg(id: 10) { <--- id jes required param
        <--- vraca 1 org
    }
}

entrypoint Auth {
    action login {}
    action logout {}
    action register {}
    action forgot_password {}
    action reset_password {}
    action update_password {}
}

entrypoint OrgEP {
    source Org
    name Organizations <-- v2
    identify with slug <-- v2
    create {
        role free_user { fieldset CreateFreeOrgFieldset }
        role paid_user { fieldset CreateOrgFieldset }

        # what if there's extra memberships data sent from client, but server adds
        # @auth as a user, would we assume `memberships.0`?
        # we're inserting two records, custom action or? this is common req I think
        transform { push memberships, { add user { "full_name" : "Mirko" } }} <-- kreiro bi se user
        transform { add memberships, [{user: @auth, org: o}]}
    }
    list {
        role superadmin
        role org_member(o), filter { is_public or } <--- ??
        role *, filter { is_public } # anyone, including anonymous Users
        # should we have implicit anonymous role? authenticated too?
    }
    get {
        role org_member(o)
        role *, filter { is_public }
    }
    update {
        role free_user { fieldset UpdateFreeOrgFieldset }
        role paid_user { fieldset UpdateOrgFieldset }

        cu fieldset UpdateFreeOrgFieldset
        crudl assert ...
        l filter ...
        crul response ...
    }
    delete { role org_admin(o) or org_editor(o) }
    entrypoint Repos {
        source o.repos
        ...
        list {
            role org_member(o)
        }
        create {}
    }
}

entrypoint {
    root Org
    list {
        features {
            search_fields org.members.full_name, min 4, pg_trym, like / startwith, required
            limit, default 10, max 1000
        }
        role superadmin
        role * {
            assert filter_field members.full_name, min 4, method like
            assert org.members.full_name in @request.query.filters
            assert @request.query.filters[org.members.full_name], min 4
            assert @@fieldset
        }
    }
    single o {
        search_key slug
        get {}
        action search {
            single
            multi
            filter
            query_params ...
            fieldset ...
            assert ...
            @hook {
                source 'hooks.js:search'
                >> context [o, r]
                >> auth @auth
                >> query_params ...
                >> data
                extra_params {...}
                
            }
        }
    }
}

fieldset CreateOrgFieldset {
    take Org.{
        name, desc, slug
        memberships.{ role }
        repos.{
            name, desc, slug
            labels                          #.{ * }
            issues.{ name, labels }
            pull_requests.{ name, labels }
        }
    }

    validate memberships {
        required, length 1
    }

    validate repos { missing }

    # enter repos {}
    take repos
}

fieldset UpdateOrgFieldset {
    validate memberships { missing }
    enter memberships {
        pick role
    }
    drop slug
    drop repos.slug
    role!!
    # imamo slucaj issue.labels se submitta cijeli
    # memberships se nikad ne submitta cijeli
    # kako znamo da ne zelimo endpoint set za issue.labels (jer je m2m),
    # a zelimo za membership? (isto m2m)
}


# A sto kad bi imali:
- entrypoint za select
    - treba nam nested filter onda.
- actions za sve ostalo
- sto je sa custom READ akcijama? ima li to smisla?
    - mozda za REST
- actions bi trebao sam moci izbuildati REST?
- ili: kako bi se buildao REST iz actionsa?


Open questions:
- kreiranje vise recorda odjednom
- sintaksa entrypointa
- sintaksa za pickanje nestanog fieldseta / kombinacija s fieldsetima, embedanje i sl.

Decisions:
- role se izvrsavaju kao case, redom do prvog matcha
- nemamo custom actiona, tj. koristimo inicijalnu action ideju (low req.)
- nestani fieldseti po zelji ako dev bas zeli, nije implicitno
- 

1. finalna sintaksa za:
- modele +
    - auth i role! <-- no rola
    - vise authova? <-- no
    - token auth? <-- no
- hooks (model, fieldset, entrypoint)
- validaciju s custom validatorima +
- entrypointove / endpointove / graphql, stogod, razmisliti o live queryjima
    - hookanje autha <-- no
    - custom actione?? <-- hook
    - slackops? <-- no
    - jslib naminga? <-- no
- transformacije vrijednosti <-- no


query UsersAndPosts {
    query users { from User }
    query posts { from Posts }
}

Post.author > reference User
User.posts -> relation Post through author

FS1 {
    field id
    field name
}

FS2 { field name }

FS3 { field id }

fieldest {
    field update FS1
    field add FS2
    field remove FS3
} > transform {
    move update memberships.$update
}

Org.insert({
    name: "my Org",
    memberships: [
        { user: { id: 1, name: "Hrvoj", "posts": [ {body: "my first post"} }]},
        { user: { name: "Marin" }}
    ]
})

Org.update({
    memberships: [{user_id: 5}]
})

$add: {}
$update: {}
$push: {}

fieldset CreatePost {
    field body string
}

fieldest CreateUser {
    field name string
    field posts CreatePost

}

fieldset CreateOrgMembership {
    field user CreateUser
}

fieldset CreateOrg {
    field name string
    field memberships CreateOrgMembership
}

fieldset CreateOrg {
    field name string
    field user_email string
}

fieldset <-- validacija podatka koji dolazi izvana

transform {
    add memberships []
    push memberships { user : {} }
    move user_email memberships.0.user.email
    move user_full_name 
}