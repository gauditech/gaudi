
model Org {
  field name { type text }
  field slug { type text, unique }
  field description { type text }

  relation repos { from Repo, through org }
}


model Repo {
  field name { type text }
  field slug { type text, unique }
  field description { type text }
  field is_public { type boolean, default true }

  reference org { to Org }
}

// ----- entrypoints

entrypoint Orgs {
  target model Org as org
  identify with slug
  response { name, slug, description }

  get endpoint {}
  list endpoint {}
  create endpoint {
    action {
      create org {}
    }
  }
  update endpoint {
    action {
      update org {}
    }
  }
  delete endpoint {}

  entrypoint Repos {
    target relation repos as repo
    response { id, slug, description, org_id }

    get endpoint {}
    list endpoint {}
    create endpoint {
      action {
        create repo {}
      }
    }
    update endpoint {
      action {
        update repo {}
      }
    }
    delete endpoint {}
  }
}

///////////

populator SomeOrg {
  target Org as org

  repeat 5 as iterator, // fixed number number of iterations - if missing, 1 is presumed
  repeat {min 3, max 15}, // random number of iterations

  // fixed value
  field name "fixed value"
  field name {
    // we can control that value matched field's datatype
    value "fixed value"
  }
  // seed uses some faker lib
  field name {
    // NOTE: we should check if seed type exists on faker lib
    // NOTE: we should check if faker lib's return value matches field's datatype
    seed { type company.name }
  }

  set name "asdfs"
  set description hook { inline `
    return faker.company.name + ' ' + faker.company.suffixes
  `}

  hint name company.name
  hint name { type company.name, options {} }
  set name "Company {iterator.current}/{iterator.total}"

  // multiple seeds with aliases
  field description {
    seed { type company.name } as companyName 
    seed { type company.suffixes, alias companySuffix }

    // template where 
    value "{companyName} {companySuffix}"
  }

  // datatypes
  field is_public {
    seed { type datatype.boolean } // datatypes: array, bigint, boolean, datetime, float, hexadecimal, json, number, string, uuid
  }

  // seed options - options object directly passed to seed lib
  // TODO: how to check available options and their datatype?
  field name {
    seed { type date.birthday, options { min: 18, max: 65, mode: "age" } }
  }

  // iteration - object { current: number, total: number }
  field name {
    value "Company {iteration.current}"
  }

  // we can check if non-nullable field is missing and throw errors

  // --- sub populators
  populator repos {
    target Repo as repo,

    repeat { min 1, max 5 }

    field name { seed { type git.branch } }

    // referencing fields in current object
    // TODO: how to reference fields assinged in DB eg. autosequence?
    field description { value "Description of {repo.name} repo" }

    // field reference to parent field - using "org" alias defined in parent populator
    set org org
  }
}

// used in development, especially testing, where we don't need lots of data but which must be predictable
populator Dev {
  // org without repos and users
  populate EmptyOrg {
    target model Org as org

    // org
    set name hook { inline`return "Organization " + ctx.iterator.current` }
    set slug hook { inline`return "org-" + ctx.iterator.current` }
    set description hook { inline`return "Description of " + ctx.org.name` }
    set optOut hook { inline`return "Opt out from org " + ctx.org.name` }
  }

  // org with 1 repo and 1 user
  populate OrgWith1RepoAnd1Member {
    target model Org as org

    // org
    set name hook { inline`return "Organization w1r1m" + ctx.iterator.current` }
    set slug hook { inline`return "org-w1r1m-" + ctx.iterator.current` }
    set description hook { inline`return "Description of " + ctx.org.name` }
    set optOut hook { inline`return "Opt out from org " + ctx.org.name` }

    // repos
    populate Repos {
      target relation repos as repo

      // fields
      set name hook { inline`return "Repo for " + org.name + " " + ctx.iterator.current` }
      set slug hook { inline`return "repo-" + org.slug + "-" + ctx.iterator.current` }
      set description hook { inline`return "Description of " + ctx.repo.name ` }
      set is_public hook { inline`return ctx.iterator.current % 2` }
    }

    // user
    populate Users {
      target model User as user

      // fields
      set name hook { inline`return "User w1r1m " + ctx.iterator.current` }

      populate UserOrgMemberships {
        target model OrgMembership

        // fields
        set user user
        set org org
      }
    }
  }

  // orgs with 3 repos and 3 users
  populate OrgWithReposAndMembers {
    target model Org as org

    repeat 3

    // fields
    set name hook { inline`return "Organization wrm" + ctx.iterator.current` }
    set slug hook { inline`return "org-wrm-" + ctx.iterator.current` }
    set description hook { inline`return "Description of " + ctx.org.name` }
    set optOut hook { inline`return "Opt out from org " + ctx.org.name` }

    populate Repos {
      target relation repos as repo

      repeat 3

      // fields
      set name hook { inline`return "Repo for " + org.name + " " + ctx.iterator.current` }
      set slug hook { inline`return "repo-" + org.slug + "-" + ctx.iterator.current` }
      set description hook { inline`return "Description of " + ctx.repo.name ` }
      set is_public hook { inline`return ctx.iterator.current % 2` }
    }
  
    // user
    populate Users {
      target model User as user

      iterate 3

      // fields
      set name hook { inline`return "User wrm " + ctx.iterator.current` }

      populate UserOrgMemberships {
        target model OrgMembership

        // fields
        set user user
        set org org
      }
    }
  }
}

// use in admin demo with lots of random data
populator AdminDemo {
  populate Org {
    target model Org as org

    repeat { min: 1000, max: 10000 }

    // fields
    set name { type company.name }
    set slug hook { inline`return faker.helpers.slugify(ctx.org.name)` }
    set description { type lorem.sentence }
    set optOut { type lorem.lines }

    populate Repos {
      target relation repos as repo

      repeat { min 0, max 100 }

      // fields
      set name { type hacker.phrase }
      set slug hook { inline`return faker.slugify(faker.company.bs())` }
      set description { type hacker.phrase }
      set is_public { type datatype.boolean }
    }
  
    // user
    populate Users {
      target model User as user

      iterate { min 1, max 500 }

      // fields
      set name { type name.fullName }

      populate UserOrgMemberships {
        target model OrgMembership

        // fields
        set user user
        set org org
      }
    }
  }
}

/*

Ideas for custom data population:
 - value stack
   * create array of const values and pop one for each iteration (eg. [true, true, false, true])
     - maybe not pop but move pointer so we can circle around the array regardles of the main iteration count
   * this allows to have desired value spread (eg. 3/4 true, 1/4 false)
   * see: https://fakerjs.dev/api/helpers.html#arrayelement
 - unique elements
   * make sure values from different iterations do no repeat on unique index fields
   * see: https://fakerjs.dev/api/helpers.html#unique
 - value cache
   * push created values (eg. ids) to some cache (eg. array) and pop/get/slice when needed
   * this allows using previously created values instead of always creating new (eg. create users and reuse them multiple times in group memberships)

*/