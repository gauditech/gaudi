create endpoint {
  target Org as org

  action {
    create Profile as profile {
      input full_name { path full_name }
    }

    create User as member {
      omit *
      input age { optional, default 7 }, name, description
      default bar
      set foo 5

      set password hook {
        arg password @data.password
        source "encryptPwd"
      }

      set profile profile
    }

    create {
      set foo 5
    }

    create Org as masterOrg {}

    create many OrgMembership as membership {
      set org org
      set user member

      create many Foo as foos {
        set membership membership
      }
    }    
  }
}

fieldset: {
  full_name: "",
  name: "",
  description: "",
  member: {
    age: "",
    username: "",
    password: "",
    profile: {}
  }
  membership: {
    role: ""
  }
}


const validators = [
  ["min", "integer"],
  ["max", "text"],
] as const;

type ValArray = typeof validators;
type Val = ValArray[number];

// https://stackoverflow.com/a/70286049
type AnyVal<T extends number> = T extends T ? { name: ValArray[T][0]; arg: ValArray[T][1] } : never;

// https//:stackoverflow.com/a/66786310
type TupleIndices<A extends readonly any[], Acc = never> = A extends [any, ...infer T]
  ? TupleIndices<T, Acc | T["length"]>
  : Acc;

// https://stackoverflow.com/a/43001581
type Writeable<T> = { -readonly [P in keyof T]: T[P] };

type Indices = TupleIndices<Writeable<ValArray>>;

const x = 0 as unknown as AnyVal<Indices>;

const n = x.name;
const a = x.arg;

if (x.name === "max") {
  const ax = x.arg;
}


1. setup e2e tests (testing http calls) in @engine
2. populator (import file)


1. fieldset support (pick models, composite validators)
2. authorization rules (extend SelectDef, pick response)
3. (unique) constraints; custom validator rules
4. fieldset error msgs


1. admin

hook compareLower {
  arg first string
  arg second string
  returns boolean
  inline `
  return first.toLowerCase() === second.toLowerCase()
  `
}

fieldset MyFieldset {
  pick Org.{name, slug, description}
  validator nameNotSlug {
    // example with inline hook and custom arg mapping
    key slug
    code "name-and-slug-equal"
    arg left @data.name
    arg right @data.slug
    deny when compareLower @data.name @data.slug
  }
  validator nameNotDesc {
    // example with builtin validator and automatic arg mapping :: (name, slug)
    key desc
    code "name-and-desc-equal"
    deny when isEqual @data.name @data.slug
  }
}

// usage in endpoint
validate with MyFieldset


// automatic arg mapping clarified:
// each validator (even hook) has default arg names that are used for constants
// fieldset fieldnames override default names

isEqual 3 5 :: first, second
min 3 5 :: value, minValue
max 5 3 :: value, maxValue
isEqual @data.name @data.profile.name :: name, 'profile.name'


TYPE SYSTEM: UNIONI I MODEL PICKOVI, CARDINALITY I NULLABLE

Contexti:


TREBA LI NAM FIELDSET??
- COMPOSITE VALIDACIJA
- CUSTOM FIELDOVI KOJI NE IDU U BAZU!!

3. VALIDATION STEPOVI (NE VRACAJ ODMAH SVE ERRORE)

create org {
  input {name, slug, description} as masterOrg
}

create org {
  input {name, slug, description} into org
  // composite validation here!
  validate nameNotSlug {
    key name
    code "name-not-slug"
    deny when hook {
      arg name @data.org.name
      arg slug @data.org.slug
      inline `return name.toLowerCase() === slug.toLowerCase()`
    }
  }
}

create User as member {
  input full_name
}
create org.org_memberships as membership {
  set role admin
  set user member
}
